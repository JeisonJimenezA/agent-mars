# utils/debug_logger.py
"""
Debug logging system for MARS framework.
Saves LLM responses, generated code, and errors for analysis.
"""

import json
import time
from pathlib import Path
from typing import Optional, Dict, Any
from datetime import datetime
from core.config import Config


class DebugLogger:
    """
    Centralized debug logging for the MARS framework.

    When DEBUG_MODE is enabled, saves:
    - LLM prompts and responses
    - Generated code
    - Execution errors
    - Node state transitions
    """

    def __init__(self, log_dir: Optional[Path] = None):
        self.log_dir = log_dir or Config.LOG_DIR / "debug"
        self.log_dir.mkdir(parents=True, exist_ok=True)

        # Session ID for this run
        self.session_id = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.session_dir = self.log_dir / self.session_id
        self.session_dir.mkdir(parents=True, exist_ok=True)

        # Counters for unique filenames
        self._llm_call_counter = 0
        self._code_gen_counter = 0
        self._error_counter = 0

        # Enable/disable based on config
        self.enabled = Config.DEBUG_MODE

        if self.enabled:
            print(f"[DebugLogger] Debug logging enabled: {self.session_dir}")

    def log_llm_call(
        self,
        agent_name: str,
        prompt: str,
        response: str,
        system_prompt: str = "",
        metadata: Optional[Dict[str, Any]] = None
    ) -> str:
        """
        Log an LLM call with prompt and response.

        Returns the log file path.
        """
        if not self.enabled:
            return ""

        self._llm_call_counter += 1
        filename = f"llm_{self._llm_call_counter:04d}_{agent_name}.json"
        filepath = self.session_dir / filename

        log_data = {
            "timestamp": datetime.now().isoformat(),
            "agent": agent_name,
            "system_prompt": system_prompt[:500] if system_prompt else "",
            "prompt": prompt,
            "response": response,
            "prompt_length": len(prompt),
            "response_length": len(response),
            "metadata": metadata or {}
        }

        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(log_data, f, indent=2, ensure_ascii=False)

        return str(filepath)

    def log_code_generation(
        self,
        module_name: str,
        generated_code: str,
        is_valid: bool,
        syntax_error: Optional[str] = None,
        agent_name: str = "CodingAgent"
    ) -> str:
        """
        Log generated code and its validation status.
        """
        if not self.enabled:
            return ""

        self._code_gen_counter += 1

        # Save the actual Python code
        code_filename = f"code_{self._code_gen_counter:04d}_{module_name}"
        code_filepath = self.session_dir / code_filename

        with open(code_filepath, 'w', encoding='utf-8') as f:
            f.write(f"# Generated by {agent_name}\n")
            f.write(f"# Module: {module_name}\n")
            f.write(f"# Valid: {is_valid}\n")
            if syntax_error:
                f.write(f"# Error: {syntax_error}\n")
            f.write(f"# Timestamp: {datetime.now().isoformat()}\n\n")
            f.write(generated_code)

        return str(code_filepath)

    def log_execution_error(
        self,
        node_id: str,
        error_type: str,
        error_message: str,
        stderr: str,
        code_files: Optional[Dict[str, str]] = None
    ) -> str:
        """
        Log an execution error with full context.
        """
        if not self.enabled:
            return ""

        self._error_counter += 1
        filename = f"error_{self._error_counter:04d}_{node_id}.json"
        filepath = self.session_dir / filename

        log_data = {
            "timestamp": datetime.now().isoformat(),
            "node_id": node_id,
            "error_type": error_type,
            "error_message": error_message,
            "stderr": stderr,
            "code_files": code_files or {}
        }

        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(log_data, f, indent=2, ensure_ascii=False)

        # Also save code files separately for easy inspection
        if code_files:
            error_code_dir = self.session_dir / f"error_{self._error_counter:04d}_code"
            error_code_dir.mkdir(exist_ok=True)
            for name, code in code_files.items():
                with open(error_code_dir / name, 'w', encoding='utf-8') as f:
                    f.write(code)

        return str(filepath)

    def log_node_state(
        self,
        node_id: str,
        action: str,
        status: str,
        metric: Optional[float] = None,
        idea: str = "",
        modules: Optional[Dict[str, str]] = None
    ):
        """
        Log a node state transition.
        """
        if not self.enabled:
            return

        filename = f"node_{node_id}_{action}.json"
        filepath = self.session_dir / filename

        log_data = {
            "timestamp": datetime.now().isoformat(),
            "node_id": node_id,
            "action": action,
            "status": status,
            "metric": metric,
            "idea": idea[:500] if idea else "",
            "modules": list(modules.keys()) if modules else []
        }

        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(log_data, f, indent=2, ensure_ascii=False)

    def log_debug_attempt(
        self,
        node_id: str,
        attempt: int,
        error_analysis: str,
        fix_applied: Optional[Dict[str, str]] = None,
        success: bool = False
    ):
        """
        Log a debugging attempt.
        """
        if not self.enabled:
            return

        filename = f"debug_{node_id}_attempt{attempt}.json"
        filepath = self.session_dir / filename

        log_data = {
            "timestamp": datetime.now().isoformat(),
            "node_id": node_id,
            "attempt": attempt,
            "error_analysis": error_analysis,
            "fix_applied": fix_applied or {},
            "success": success
        }

        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(log_data, f, indent=2, ensure_ascii=False)

    def get_session_summary(self) -> Dict[str, Any]:
        """
        Get a summary of this debug session.
        """
        return {
            "session_id": self.session_id,
            "session_dir": str(self.session_dir),
            "llm_calls": self._llm_call_counter,
            "code_generations": self._code_gen_counter,
            "errors": self._error_counter,
            "enabled": self.enabled
        }


# Global instance
_debug_logger: Optional[DebugLogger] = None


def get_debug_logger() -> DebugLogger:
    """Get or create the global debug logger."""
    global _debug_logger
    if _debug_logger is None:
        _debug_logger = DebugLogger()
    return _debug_logger
